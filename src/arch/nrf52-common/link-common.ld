/*******************************************************************************/
/*  © Université de Lille, The Pip Development Team (2015-2022)                */
/*                                                                             */
/*  This software is a computer program whose purpose is to run a minimal,     */
/*  hypervisor relying on proven properties such as memory isolation.          */
/*                                                                             */
/*  This software is governed by the CeCILL license under French law and       */
/*  abiding by the rules of distribution of free software.  You can  use,      */
/*  modify and/ or redistribute the software under the terms of the CeCILL     */
/*  license as circulated by CEA, CNRS and INRIA at the following URL          */
/*  "http://www.cecill.info".                                                  */
/*                                                                             */
/*  As a counterpart to the access to the source code and  rights to copy,     */
/*  modify and redistribute granted by the license, users are provided only    */
/*  with a limited warranty  and the software's author,  the holder of the     */
/*  economic rights,  and the successive licensors  have only  limited         */
/*  liability.                                                                 */
/*                                                                             */
/*  In this respect, the user's attention is drawn to the risks associated     */
/*  with loading,  using,  modifying and/or developing or reproducing the      */
/*  software by the user in light of its specific status of free software,     */
/*  that may mean  that it is complicated to manipulate,  and  that  also      */
/*  therefore means  that it is reserved for developers  and  experienced      */
/*  professionals having in-depth computer knowledge. Users are therefore      */
/*  encouraged to load and test the software's suitability as regards their    */
/*  requirements in conditions enabling the security of their systems and/or   */
/*  data to be ensured and,  more generally, to use and operate it in the      */
/*  same conditions as regards security.                                       */
/*                                                                             */
/*  The fact that you are presently reading this means that you have had       */
/*  knowledge of the CeCILL license and that you accept its terms.             */
/*******************************************************************************/

OUTPUT_FORMAT("elf32-littlearm")
OUTPUT_ARCH(arm)

ENTRY(_start)
/*
 * Default stack sizes.
 * These are used by the startup in order to allocate stacks
 * for the different modes.
 */

__Main_Stack_Size = 1024*2 ;
__Heap_Size = 1024 ;
__User_Stack_Size = 1024 ; /* must be a power of two else will be ceiled to be so */

/* Populate information about ram size */
_sram = ORIGIN(RAM);
_eram = ORIGIN(RAM) + LENGTH(RAM);

/* Populate information about rom size */
_srom = ORIGIN(FLASH);
_erom = ORIGIN(FLASH) + LENGTH(FLASH);

/* Section Definitions */
SECTIONS
{
  /*
     * For Cortex-M devices, the beginning of the startup code is stored in
     * the .isr_vector section, which goes to FLASH.
     */
    .isr_vector : ALIGN(4)
    {
        FILL(0xFF)

        __vectors_start = ABSOLUTE(.) ;
        __vectors_start__ = ABSOLUTE(.) ; /* STM specific definition */
        KEEP(*(.isr_vector))     	/* Interrupt vectors */

        /*
          * This section is here for convenience, to store the
          * startup code at the beginning of the flash area, hoping that
          * this will increase the readability of the listing.
          */
        *(.after_vectors .after_vectors.*)	/* Startup code and ISR */

        KEEP(*(.eh_frame*))

        /*
		 * Stub sections generated by the linker, to glue together
		 * ARM and Thumb code. .glue_7 is used for ARM code calling
		 * Thumb code, and .glue_7t is used for Thumb code calling
		 * ARM code. Apparently always generated by the linker, for some
		 * architectures, so better leave them here.
		 */
        *(.glue_7)
        *(.glue_7t)

    } >FLASH

	/*
	 * The program code is stored in the .text section,
	 * which goes to FLASH.
	 */

    .text_pip : ALIGN(4)
    {
        _stext = .;
        *(.text_pip)
    } > FLASH

    .text_pipcore : ALIGN(4)
    {
        *(.text_pipcore)
    } > FLASH

    .text_pip_init : ALIGN(4)
    {
        *(.text_pip_init)
    } > FLASH

    .text_pip_mal : ALIGN(4)
    {
        *(.text_pip_mal)
    } > FLASH

	.text : ALIGN(4)
	{
		_stext = .;
		*(.text .text.*) /* all remaining code */
        _epiptext = .;

 		/* read-only data (constants) */
		*(.rodata .rodata.* .rodata_pip)

		/*
		 *
		 */

		. = ALIGN(32);

		_smultiplexer = . ;
		*(.multiplexer*)
		_emultiplexer = . ;

		_etext = .;
	} > FLASH

	/*
     * This address is used by the startup code to
     * initialise the .data section.
     */
    _sidata = LOADADDR(.data);
    /*
     * The initialised data section.
     *
     * The program executes knowing that the data is in the RAM
     * but the loader puts the initial values in the FLASH (inidata).
     * It is one task of the startup to copy the initial values from
     * FLASH to RAM.
     */
    .data : ALIGN(4)
    {
        FILL(0xFF)
        /* This is used by the startup code to initialise the .data section */
        _sdata = . ;        	/* STM specific definition */

        *(.data .data.*)

        . = ALIGN(4);

	      /* This is used by the startup code to initialise the .data section */
        _edata = . ;        	/* STM specific definition */

    } >RAM AT>FLASH

    /*
     * The uninitialised data sections. NOLOAD is used to avoid
     * the "section `.bss' type changed to PROGBITS" warning
     */
    /* .bss section which is used for uninitialized data */
    .bss_pip (NOLOAD) :
    {
        . = ALIGN(4);
        _sbss = .;
        *(.bss_pip)
        *(COMMON)
        . = ALIGN(4);
    } > RAM

    .bss (NOLOAD) :
    {
        . = ALIGN(4);
        /*_sbss = .;*/
        *(.bss .bss.*)
        *(COMMON)
        . = ALIGN(4);
        _ebss = .;
    } > RAM

    .heap (NOLOAD) :
    {
        __HeapBase = .;
        _Heap_Begin = __HeapBase;
        KEEP(*(.heap*))
        . = . + __Heap_Size;
        __HeapLimit = .;
        _Heap_Limit = __HeapLimit ;
    } > RAM

    /* stack section */

    .stack (NOLOAD):
    {
        . = ALIGN(8);
        __StackLimit = .;
        . = . + __Main_Stack_Size;
        . = ALIGN(8);
        __StackTop = .;
      /* Check if data + heap + stack exceeds RAM limit */
      ASSERT(__HeapLimit <= __StackLimit, "region RAM overflowed");

    } > RAM

    /* USER SECTION */
    .userland (NOLOAD) :
    {
        . = ALIGN(1024); /* Align to MPU region grain */
        user_mem_start = .;
    } > RAM
    user_mem_end = _eram;

    /* Set the user stack at end of RAM with MPU alignment constraints */
    ASSERT(32 <= __User_Stack_Size, "stack size too small")

    /*_user_stack_size_aligned = (1 << (LOG2CEIL(__User_Stack_Size)-1)); /* 2^(log2(stack size not aligned)-1) */
    /*user_stack_limit = ALIGN(_eram - (_user_stack_size_aligned << 1) + 1, _user_stack_size_aligned); /* be sure to align at end of RAM */
    user_stack_limit = ALIGN(_eram - 2*__User_Stack_Size + 1, __User_Stack_Size);
    /*user_stack_top = user_stack_limit + _user_stack_size_aligned;*/
    user_stack_top = user_stack_limit + __User_Stack_Size;


    ASSERT(user_mem_start <= user_stack_limit, "stack limit before start of RAM")
    ASSERT(user_stack_top <= _eram , "stack top higher than end of RAM")
    ASSERT(user_mem_end >= _eram , "User memory stretches over end of RAM")

    /*_end = . ;*/

    /* Set stack top to end of RAM, and stack limit move down by
	 * size of stack_dummy section */

/* Check if text sections + data exceeds FLASH limit */
    DataInitFlashUsed = _sbss - _sdata;
    CodeFlashUsed = _etext - ORIGIN(FLASH);
    TotalFlashUsed = CodeFlashUsed + DataInitFlashUsed;
    ASSERT(TotalFlashUsed <= LENGTH(FLASH), "region FLASH overflowed with .data and user data")
}
